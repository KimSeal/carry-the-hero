#include <iostream>
#include <vector>
#include <queue>
using namespace std;

void bfs(int n,int m,int meY,int meX,int juY, 
						int juX,int oldmap[7][7]);

int main(){
	//int n;//n은 방 세로사이즈
	//int m;//m은 방 가로사이즈
	//int meY;//개체 세로축
	//int meX;//개체 가로축
	//int juY;//주인공 세로축
	//int juX;//주인공 가로축
	int newmap[7][7]={{1,1,1,1,1,1,1},
				   {1,0,0,0,0,0,1},
				   {1,0,0,0,0,0,1},
				   {1,0,0,0,0,0,1},
				   {1,0,0,0,0,0,1},
				   {1,0,0,0,0,0,1},
				   {1,1,1,1,1,1,1}};
	bfs(7,7,0,0,6,6,newmap);
	//bfs(n,m,meY,meX,juY,juX,map[][30]);//2차원 배열의 가로 최대치 지정후 map을 사용할 예정
	return 0;
}

class Node{
	public:
	int row, col, dist;
	vector<int>row2;
	vector<int>col2;
	void node_Make(int oldrow, int oldcol, int olddist, vector<int> oldrow2, vector<int> oldcol2){
		this->row=oldrow;
		this->col=oldcol;
		this->dist=olddist;
		this->row2.clear();
		this->row2.assign(oldrow2.begin(), oldrow2.end());
		this->row2.push_back(oldrow);
		this->col2.clear();
		this->col2.assign(oldcol2.begin(), oldcol2.end());
		this->col2.push_back(oldcol);
	}
};

void bfs(int n,int m,int meY,int meX,int juY, int juX,int oldmap[7][7]){
	int n1=n;
	int m1=m;
	int curRow=0;
	int curCol=0;
	int curDist=1;
	vector<int>curRows;
	vector<int>curCols;
	
	vector<vector<int>> map;
	vector<int>map2;
	for(int i=0;i<n;i++){
		map.push_back(map2);
		for(int j=0;j<m;j++){
			map[i].push_back(oldmap[i][j]);
			cout<<map[i][j]<<" ";
		}
		cout<<"\n";
	}
	//외부 2차원 맵 복사
	
	queue<Node> q;
	Node mainnode, mainnode2;
	mainnode.node_Make(meY,meX,0,{meY},{meX});
	q.push(mainnode);
	while(!q.empty()){
		mainnode.node_Make(q.front().row, q.front().col, q.front().dist, q.front().row2, q.front().col2);
		//cout << q.front().row << q.front().col << q.front().dist;
		cout<<q.front().row2[0] << q.front().col2[0];
		q.pop();
		curRow = mainnode2.row;
        curCol = mainnode2.col;
        curDist = mainnode2.dist;
        map[curRow][curCol] = 0;
        cout << curRow << " "<<curCol<<" "<<curDist<<"\n";
        // 목적지에 도착하면 루핑 종료
        if(curRow == juY && curCol == juX) {
			cout<<juY<<juX<<"weare error";
            break;
        }
        cout<<"upchek";
		cout <<curRow-1<<" "<<map[curRow-1][curCol]<<"\n";
        // 위로 갈수 있으면
        if(curRow-1 >= 0 && map[curRow-1][curCol] == 1) {
			mainnode2.node_Make(curRow-1, curCol, curDist+1, curRows, curCols);
            q.push(mainnode2);
        }
        // 아래로 갈수 있으면
		cout<<"downchek";
        if(curRow+1 < n1 && map[curRow+1][curCol] == 1) {
            mainnode2.node_Make(curRow+1, curCol, curDist+1, curRows, curCols);
			q.push(mainnode2);
			cout<<"down did!\n";
        }
        // 왼쪽으로 갈수 있으면
		cout<<"leftchek";
        if(curCol-1 >= 0 && map[curRow][curCol-1] == 1) {
            mainnode2.node_Make(curRow, curCol-1, curDist+1, curRows, curCols);
			q.push(mainnode2);
        }
    	// 오른쪽으로 갈수 있으면
		cout<<"rightchek";
        if(curCol+1 < m1 && map[curRow][curCol+1] == 1) {
            mainnode2.node_Make(curRow, curCol+1, curDist+1, curRows, curCols);
        	q.push(mainnode2);
			cout<<"right did!\n";
		}
	}
	cout <<"clear!";
	//만들어진 가로, 세로 배열 복사
	for(int i=0;i<curRows.size();i++){
		cout << mainnode.row2[i]<<" ";
	}
	for(int i=0;i<curCols.size();i++){
		cout << mainnode.col2[i]<<" ";
	}
	 while(!q.empty()){
        q.pop();
    }
}
